# Приклад Dumbshell

## [Програмний код](dumbsh.c)

## Опис:

Протестовано наданий приклад програми dumbshell. У ньому ввід користувача записується у буфер line,
створюється дочірній процес з fork, після чого вміст line передається у execlp() (у створеному дочірньому
процесі, тобто коли pid == 0, що і дає програмі знати що вона зараз виконує дочірній процес). execlp() повністю
замінює дочірній процес процесом виконання команди, яку йому поредали, тобто в прикладі тестування це процеси
ls, whoami, exit, які виконується як консольні команди і дозволяють симулювати оболонку shell.

## Результат виконання:

```
max@aspz:~/c/10 $ gcc -Wall dumbsh.c -o dumbsh
dumbsh.c: In function 'main':
dumbsh.c:25:13: warning: implicit declaration of function 'wait' [-Wimplicit-function-declaration]
   25 |             wait(NULL);
      |             ^~~~
max@aspz:~/c/10 $ ./dumbsh
dumbsh> ls
1               1.c             dumbsh          dumbsh.c        readmyass.txt
dumbsh> whoami
max
dumbsh> exit
max@aspz:~/c/10 $
```

# Приклад API wait

## [Програмний код](api_wait.c)

## Опис:

Наданий приклад розширено (оскільки сам по собі він не працював і так то нічого корисного не демонстрував),
і запущено для перегляду роботи API wait(). У прикладі з fork() створюється дочірній процес, який виходить з
конкретним статусом (для тестування обрано exit(69)), що бачить батьківський процес після очікування на
завершення будь-якого дочірнього процесу за допомогою wait(&status), отримуючи статус процесу, що завершився у
status. Батьківський використовує WIFEXITED() для перевірки, чи процес завершився нормально (типу exit чи
досягнення кінця main, в противному випадку завершитись може сигналом), після чого WEXITSTATUS отримує код,
з яким завершився цей дочірній процес.

## Результат виконання:

```
ax@aspz:~/c/10 $ gcc -Wall api_wait.c -o api_wait
max@aspz:~/c/10 $ ./api_wait
This is parent, waiting for child...
This is child 1550, exit(69)...
This is parent, child 1550 exited
Exited with code 69
```

# Приклад створення кількох дітей

## [Програмний код](many_children.c)

## Опис:

Приклад, наданий у лекції, дороблено парою повідомлень виводу та запущено. У прикладі ричі за допомогою
fork() створюються 3 дочірніх процеси, кожний з яких виводить свій номер (число i з for) та виходить.
Батьківський процес чекає на завершення всіх дочірніх, використовуючи ф-цію wait(NULL), яка повертатиме
значення більше за 0, тобто pid дочірнього процесу, завершення якого вона дочекалася, аж поки не
дочекається завершення всіх (while wait(NULL) > 0). Тут NULL передається як аргумент, бо не потрібні
статуси дочірніх процесів, їх завершення в прикладі потрібно просто дочекатись.

## Результат виконання:

```
ax@aspz:~/c/10 $ gcc -Wall many_children.c -o many_children
max@aspz:~/c/10 $ ./many_children
Creating 3 children
Child 0
Child 1
Child 2
All children exited
max@aspz:~/c/10 $
```

# Завдання за варіантом 18

## Умова:

Додайте до програми обробник сигналу SIGCHLD, який буде виводити повідомлення про завершення дочірнього процесу.

## [Програмний код](4.c)

## Опис:

Написано програму, у якій створюється дочірній процес, який виводить пару повідомлень, між якими спить (типу щось
робить), поки батько стоїть на паузі (pause()) і чекає на якийсь сигнал. Створено обробник сигналу SIGCHLD,
sig_handler(), який прив'язується до сигналу командою signal() на початку програми. За допомогою fork() створюється
дочірній процес, який імітує роботу (каже дві фрази та спить (як справжня людина)) і потім виходить, надсилаючи
сигнал SIGCHLD батьківському процесу (у якому встановлений хендлер). Обробник сигналу спочатку "збирає" дочірній
процес через wait(NULL), оскільки в ситуаціях, коли батько спить (тут - pause()), а паралельно дитина щось робить
і завершує роботу, вона повідомляє батьку, що з системного списку сигналів її pid можна видалити, але якщо батько в
цей час спить, то таке повідомлення може бути пропущене, і залишиться "zombie" процес, який завершився і нічого не
робить, але його pid існує в списку активних у системі. Після цього хендлер виводить повідомлення, а батько отримує
сигнал, тому прокинається від pause() та виводить про це повідомлення, що видно у результатах виконання.

## Результат виконання:

```
max@aspz:~/c/10 $ gcc -Wall 1.c -o 1
max@aspz:~/c/10 $ ./1
This is parent, created child 1981, waiting for sig...
This is child 1981, waiting 3 sec...
Child exiting...
SIGCHLD detected, child exited
Parent exiting...
max@aspz:~/c/10 $
```
